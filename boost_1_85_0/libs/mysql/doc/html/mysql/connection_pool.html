<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>(Experimental) Connection pools</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter 1. Boost.MySQL">
<link rel="up" href="../index.html" title="Chapter 1. Boost.MySQL">
<link rel="prev" href="any_connection.html" title="(Experimental) Type-erased connections with any_connection">
<link rel="next" href="sql_formatting.html" title="(Experimental) Client-side SQL query formatting">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="any_connection.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="sql_formatting.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="mysql.connection_pool"></a><a class="link" href="connection_pool.html" title="(Experimental) Connection pools">(Experimental) Connection pools</a>
</h2></div></div></div>
<p>
      Connection pooling is a technique where several long-lived connections are
      re-used for independent logical operations. When compared to establishing individual
      connections, it has the following benefits:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          It provides better performance. Please consult <a class="link" href="connection_pool.html#mysql.connection_pool.benchmarks">our
          benchmarks</a> for more info.
        </li>
<li class="listitem">
          It simplifies connection management. The connection pool will establish
          sessions, perform retries and apply timeouts out of the box.
        </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        This feature is experimental. Its API may change in subsequent releases.
      </p></td></tr>
</table></div>
<p>
      This is how you can create a pool of connections:
    </p>
<pre class="programlisting"><span class="comment">// pool_params contains configuration for the pool.</span>
<span class="comment">// You must specify enough information to establish a connection,</span>
<span class="comment">// including the server address and credentials.</span>
<span class="comment">// You can configure a lot of other things, like pool limits</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>

<span class="comment">// The I/O context, required by all I/O operations</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_context</span> <span class="identifier">ctx</span><span class="special">;</span>

<span class="comment">// Construct a pool of connections. The context will be used internally</span>
<span class="comment">// to create the connections and other I/O objects</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">));</span>

<span class="comment">// You need to call async_run on the pool before doing anything useful with it.</span>
<span class="comment">// async_run creates connections and keeps them healthy. It must be called</span>
<span class="comment">// only once per pool.</span>
<span class="comment">// The detached completion token means that we don't want to be notified when</span>
<span class="comment">// the operation ends. It's similar to a no-op callback.</span>
<span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_run</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detached</span><span class="special">);</span>
</pre>
<p>
      <a class="link" href="ref/boost__mysql__connection_pool.html" title="connection_pool"><code class="literal">connection_pool</code></a>
      is an I/O object that manages connections. It can be constructed from an executor
      or execution context (like all I/O objects) and a <a class="link" href="ref/boost__mysql__pool_params.html" title="pool_params"><code class="literal">pool_params</code></a>
      object.
    </p>
<p>
      <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">connection_pool::async_run</code></a>
      must be called exactly once per pool. This function takes care of actually
      keeping connections healthy.
    </p>
<p>
      We're now ready to obtain connections using <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>.
      We will use C++20 coroutines to make async code simpler:
    </p>
<pre class="programlisting"><span class="comment">// Use connection pools for functions that will be called</span>
<span class="comment">// repeatedly during the application lifetime.</span>
<span class="comment">// An HTTP server handler function is a good candidate.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">awaitable</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">int64_t</span><span class="special">&gt;</span> <span class="identifier">get_num_employees</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Get a fresh connection from the pool.</span>
    <span class="comment">// pooled_connection is a proxy to an any_connection object.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">conn</span> <span class="special">=</span> <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_awaitable</span><span class="special">);</span>

    <span class="comment">// Use pooled_connection::operator-&gt; to access the underlying any_connection.</span>
    <span class="comment">// Let's use the connection</span>
    <span class="identifier">results</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">co_await</span> <span class="identifier">conn</span><span class="special">-&gt;</span><span class="identifier">async_execute</span><span class="special">(</span><span class="string">"SELECT COUNT(*) FROM employee"</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_awaitable</span><span class="special">);</span>
    <span class="identifier">co_return</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">rows</span><span class="special">().</span><span class="identifier">at</span><span class="special">(</span><span class="number">0</span><span class="special">).</span><span class="identifier">at</span><span class="special">(</span><span class="number">0</span><span class="special">).</span><span class="identifier">as_int64</span><span class="special">();</span>

    <span class="comment">// When conn is destroyed, the connection is returned to the pool</span>
<span class="special">}</span>
</pre>
<p>
      By default, <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">connection_pool::async_run</code></a>
      will run forever. When your application exits, you will want to stop it using
      <a class="link" href="ref/boost__mysql__connection_pool/cancel.html" title="connection_pool::cancel"><code class="literal">connection_pool::cancel</code></a>.
      This is typical in signal handlers, to guarantee a clean shutdown.
    </p>
<p>
      Note that pooling works only with <a class="link" href="ref/boost__mysql__any_connection.html" title="any_connection"><code class="literal">any_connection</code></a>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        <code class="computeroutput"><span class="identifier">connection_pool</span></code> exposes async
        functions only. This has to do with efficiency and oddities in Boost.Asio
        executor model. If you need a sync API, please visit <a class="link" href="connection_pool.html#mysql.connection_pool.sync">this
        section</a>.
      </p></td></tr>
</table></div>
<h4>
<a name="mysql.connection_pool.h0"></a>
      <span class="phrase"><a name="mysql.connection_pool.pool_size"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.pool_size">Pool
      size</a>
    </h4>
<p>
      Pools start with a fixed initial size, and will be dynamically resized up to
      an upper limit if required. You can configure these sizes using <a class="link" href="ref/boost__mysql__pool_params/initial_size.html" title="pool_params::initial_size"><code class="literal">pool_params::initial_size</code></a>
      and <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>.
    </p>
<p>
      The resizing algorithm works like this:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          When the pool is created, <a class="link" href="ref/boost__mysql__pool_params/initial_size.html" title="pool_params::initial_size"><code class="literal">pool_params::initial_size</code></a>
          number of connections are created and connected (by default, <code class="computeroutput"><span class="identifier">initial_size</span></code> is 1).
        </li>
<li class="listitem">
          If a connection is requested, but all available connections are in use,
          a new one is created, until <code class="computeroutput"><span class="identifier">max_size</span></code>
          is reached.
        </li>
<li class="listitem">
          If a connection is requested, and there are <code class="computeroutput"><span class="identifier">max_size</span></code>
          connections in use, <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>
          waits for a connection to become available, up to a certain period of time.
          If no connection is available after this period, the operation fails.
        </li>
<li class="listitem">
          Once created, connections never get deallocated.
        </li>
</ul></div>
<p>
      By default, <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>
      is 151, which is MySQL's default value for the <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections" target="_top"><code class="computeroutput"><span class="identifier">max_connections</span></code></a> system variable,
      controlling the maximum number of concurrent connections allowed by the server.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        Before increasing <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>,
        make sure to also increase the value of <code class="computeroutput"><span class="identifier">max_connections</span></code>
        in the server. Otherwise, your connections will be rejected by the connection
        limit.
      </p></td></tr>
</table></div>
<p>
      This is how you configure pool sizes:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>

<span class="comment">// Set the usual params</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>

<span class="comment">// Create 10 connections at startup, and allow up to 1000 connections</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">initial_size</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">max_size</span> <span class="special">=</span> <span class="number">1000</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">));</span>
</pre>
<h4>
<a name="mysql.connection_pool.h1"></a>
      <span class="phrase"><a name="mysql.connection_pool.session_state"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.session_state">Session
      state</a>
    </h4>
<p>
      MySQL connections hold state. You change session state when you prepare statements,
      create temporary tables, start transactions, or set session variables. When
      using pooled connections, session state can be problematic: if not reset properly,
      state from a previous operation may affect subsequent ones.
    </p>
<p>
      After you return a connection to the pool, the equivalent of <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">any_connection::async_reset_connection</code></a>
      and <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">async_set_character_set</code></a>
      are used to wipe session state before the connection can be obtained again.
      This will deallocate prepared statements, rollback uncommitted transactions,
      clear variables and restore the connection's character set to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>. In particular, you don't need to
      call <a class="link" href="ref/boost__mysql__any_connection/async_close_statement.html" title="any_connection::async_close_statement"><code class="literal">any_connection::async_close_statement</code></a>
      to deallocate statements.
    </p>
<p>
      Resetting a connection is cheap but entails a cost (a roundtrip to the server).
      If you've used a connection and you know that you didn't mutate session state,
      you can use <a class="link" href="ref/boost__mysql__pooled_connection/return_without_reset.html" title="pooled_connection::return_without_reset"><code class="literal">pooled_connection::return_without_reset</code></a>
      to skip resetting. For instance:
    </p>
<pre class="programlisting"><span class="comment">// Get a connection from the pool</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">conn</span> <span class="special">=</span> <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_awaitable</span><span class="special">);</span>

<span class="comment">// Use the connection in a way that doesn't mutate session state.</span>
<span class="comment">// We're not setting variables, preparing statements or starting transactions,</span>
<span class="comment">// so it's safe to skip reset</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">results</span> <span class="identifier">result</span><span class="special">;</span>
<span class="identifier">co_await</span> <span class="identifier">conn</span><span class="special">-&gt;</span><span class="identifier">async_execute</span><span class="special">(</span><span class="string">"SELECT COUNT(*) FROM employee"</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_awaitable</span><span class="special">);</span>

<span class="comment">// Explicitly return the connection to the pool, skipping reset</span>
<span class="identifier">conn</span><span class="special">.</span><span class="identifier">return_without_reset</span><span class="special">();</span>
</pre>
<p>
      Connection reset happens in the background, after the connection has been returned,
      so it does not affect latency. If you're not sure if an operation affects state
      or not, assume it does.
    </p>
<h4>
<a name="mysql.connection_pool.h2"></a>
      <span class="phrase"><a name="mysql.connection_pool.character_set"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.character_set">Character
      set</a>
    </h4>
<p>
      Pooled connections always use <code class="computeroutput"><span class="identifier">utf8mb4</span></code>
      as its character set. When connections are reset, the equivalent of <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">any_connection::async_set_character_set</code></a>
      is used to restore the character set to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>
      (recall that raw <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">async_reset_connection</code></a>
      will wipe character set data).
    </p>
<p>
      Pooled connections always know the character set they're using. This means
      that <a class="link" href="ref/boost__mysql__any_connection/format_opts.html" title="any_connection::format_opts"><code class="literal">any_connection::format_opts</code></a>
      and <a class="link" href="ref/boost__mysql__any_connection/current_character_set.html" title="any_connection::current_character_set"><code class="literal">current_character_set</code></a>
      always succeed.
    </p>
<p>
      We recommend to always stick to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>.
      If you really need to use any other character set, use <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">async_set_character_set</code></a>
      on your connection after it's been retrieved from the pool.
    </p>
<h4>
<a name="mysql.connection_pool.h3"></a>
      <span class="phrase"><a name="mysql.connection_pool.connection_lifecycle"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.connection_lifecycle">Connection
      lifecycle</a>
    </h4>
<p>
      The behavior already explained can be summarized using a state model like the
      following:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="images/pooled_connection_lifecycle.svg" align="middle"></object></span>
    </p>
<p>
      In short:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          When a connection is created, it goes into the <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          state.
        </li>
<li class="listitem">
          Connection establishment is attempted. If it succeeds, the connection becomes
          <code class="computeroutput"><span class="identifier">idle</span></code>. Otherwise, it stays
          <code class="computeroutput"><span class="identifier">pending_connect</span></code>, and another
          attempt will be performed after <a class="link" href="ref/boost__mysql__pool_params/retry_interval.html" title="pool_params::retry_interval"><code class="literal">pool_params::retry_interval</code></a>
          has ellapsed.
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">idle</span></code> connections can be
          retrieved by <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>,
          and they become <code class="computeroutput"><span class="identifier">in_use</span></code>.
        </li>
<li class="listitem">
          If a connection is returned by <a class="link" href="ref/boost__mysql__pooled_connection/return_without_reset.html" title="pooled_connection::return_without_reset"><code class="literal">pooled_connection::return_without_reset</code></a>,
          it becomes <code class="computeroutput"><span class="identifier">idle</span></code> again.
        </li>
<li class="listitem">
          If a connection is returned by <a class="link" href="ref/boost__mysql__pooled_connection.html" title="pooled_connection"><code class="literal">pooled_connection</code></a>'s
          destructor, it becomes <code class="computeroutput"><span class="identifier">pending_reset</span></code>.
        </li>
<li class="listitem">
          <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">any_connection::async_reset_connection</code></a>
          is applied to <code class="computeroutput"><span class="identifier">pending_reset</span></code>
          connections. On success, they become <code class="computeroutput"><span class="identifier">idle</span></code>
          again. Otherwise, they become <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          and will be reconnected.
        </li>
<li class="listitem">
          If a connection stays <code class="computeroutput"><span class="identifier">idle</span></code>
          for <a class="link" href="ref/boost__mysql__pool_params/ping_interval.html" title="pool_params::ping_interval"><code class="literal">pool_params::ping_interval</code></a>,
          it becomes <code class="computeroutput"><span class="identifier">pending_ping</span></code>.
          At this point, the connection is probed. If it's alive, it will return
          to being <code class="computeroutput"><span class="identifier">idle</span></code>. Otherwise,
          it becomes <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          to be reconnected. Pings can be disabled by setting <a class="link" href="ref/boost__mysql__pool_params/ping_interval.html" title="pool_params::ping_interval"><code class="literal">pool_params::ping_interval</code></a>
          to zero.
        </li>
</ul></div>
<h4>
<a name="mysql.connection_pool.h4"></a>
      <span class="phrase"><a name="mysql.connection_pool.thread_safety_and_executors"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.thread_safety_and_executors">Thread-safety
      and executors</a>
    </h4>
<p>
      By default, <a class="link" href="ref/boost__mysql__connection_pool.html" title="connection_pool"><code class="literal">connection_pool</code></a>
      is <span class="bold"><strong>NOT thread-safe</strong></span>, but it can be easily made
      thread-safe by using:
    </p>
<pre class="programlisting"><span class="comment">// The I/O context, required by all I/O operations</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_context</span> <span class="identifier">ctx</span><span class="special">;</span>

<span class="comment">// The usual pool configuration params</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>

<span class="comment">// By passing pool_executor_params::thread_safe to connection_pool,</span>
<span class="comment">// we make all its member functions thread-safe.</span>
<span class="comment">// This works by creating a strand.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_executor_params</span><span class="special">::</span><span class="identifier">thread_safe</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">()),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">)</span>
<span class="special">);</span>

<span class="comment">// We can now pass a reference to pool to other threads,</span>
<span class="comment">// and call async_get_connection concurrently without problem.</span>
<span class="comment">// Inidivudal connections are still not thread-safe.</span>
</pre>
<p>
      This works by using strands. Recall that a <a href="../../../../../doc/html/boost_asio/reference/strand.html" target="_top"><code class="literal">boost::asio::strand</code></a>
      is Asio's method to enable concurrency without explicit locking. A strand is
      an executor that wraps another executor. All handlers dispatched through a
      strand will be serialized: no two handlers will be run in parallel, which avoids
      data races.
    </p>
<p>
      We're passing a <a class="link" href="ref/boost__mysql__pool_executor_params.html" title="pool_executor_params"><code class="literal">pool_executor_params</code></a>
      instance to the pool's constructor, which contains two executors:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <a class="link" href="ref/boost__mysql__pool_executor_params/pool_executor.html" title="pool_executor_params::pool_executor"><code class="literal">pool_executor_params::pool_executor</code></a>
          is used to run <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">connection_pool::async_run</code></a>
          and <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>
          intermediate handlers. By using <a class="link" href="ref/boost__mysql__pool_executor_params/thread_safe.html" title="pool_executor_params::thread_safe"><code class="literal">pool_executor_params::thread_safe</code></a>,
          a strand is created, and all these handlers will be serialized.
        </li>
<li class="listitem">
          <a class="link" href="ref/boost__mysql__pool_executor_params/connection_executor.html" title="pool_executor_params::connection_executor"><code class="literal">pool_executor_params::connection_executor</code></a>
          is used to construct connections. By default, this won't be wrapped in
          any strand, and inividual connections will not be thread-safe.
        </li>
</ul></div>
<h4>
<a name="mysql.connection_pool.h5"></a>
      <span class="phrase"><a name="mysql.connection_pool.transport_types_and_tls"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.transport_types_and_tls">Transport
      types and TLS</a>
    </h4>
<p>
      You can use the same set of transports as when working with <a class="link" href="ref/boost__mysql__any_connection.html" title="any_connection"><code class="literal">any_connection</code></a>:
      plaintext TCP, TLS over TCP or UNIX sockets. You can configure them using
      <a class="link" href="ref/boost__mysql__pool_params/server_address.html" title="pool_params::server_address"><code class="literal">pool_params::server_address</code></a>
      and <a class="link" href="ref/boost__mysql__pool_params/ssl.html" title="pool_params::ssl"><code class="literal">pool_params::ssl</code></a>.
      By default, TLS over TCP will be used if the server supports it, falling back
      to plaintext TCP if it does not.
    </p>
<p>
      You can use <a class="link" href="ref/boost__mysql__pool_params/ssl_ctx.html" title="pool_params::ssl_ctx"><code class="literal">pool_params::ssl_ctx</code></a>
      to configure TLS options for connections created by the pool. If no context
      is provided, one will be created for you internally.
    </p>
<h4>
<a name="mysql.connection_pool.h6"></a>
      <span class="phrase"><a name="mysql.connection_pool.sync"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.sync">Implementing
      sync functions</a>
    </h4>
<p>
      <code class="computeroutput"><span class="identifier">connection_pool</span></code> is internally
      implemented in terms of <code class="computeroutput"><span class="identifier">any_connection</span></code>
      async functions because:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          When managing hundrends of connections, it's much more efficient to use
          async functions and a limited number of threads, than a thread per connection.
        </li>
<li class="listitem">
          Sync functions don't allow setting timeouts.
        </li>
</ul></div>
<p>
      You can build a sync connection pool on top of <code class="computeroutput"><span class="identifier">connection_pool</span></code>
      using code like this:
    </p>
<pre class="programlisting"><span class="comment">// Wraps a connection_pool and offers a sync interface.</span>
<span class="comment">// sync_pool is thread-safe</span>
<span class="keyword">class</span> <span class="identifier">sync_pool</span>
<span class="special">{</span>
    <span class="comment">// A thread pool with a single thread. This is used to</span>
    <span class="comment">// run the connection pool. The thread is automatically</span>
    <span class="comment">// joined when sync_pool is destroyed.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">thread_pool</span> <span class="identifier">thread_pool_</span><span class="special">{</span><span class="number">1</span><span class="special">};</span>

    <span class="comment">// The async connection pool</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">conn_pool_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Constructor: constructs the connection_pool object from</span>
    <span class="comment">// the single-thread pool and calls async_run.</span>
    <span class="comment">// The pool has a single thread, which creates an implicit strand.</span>
    <span class="comment">// There is no need to use pool_executor_params::thread_safe</span>
    <span class="identifier">sync_pool</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">conn_pool_</span><span class="special">(</span><span class="identifier">thread_pool_</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="comment">// Run the pool in the background (this is performed by the thread_pool thread).</span>
        <span class="comment">// When sync_pool is destroyed, this task will be stopped and joined automatically.</span>
        <span class="identifier">conn_pool_</span><span class="special">.</span><span class="identifier">async_run</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detached</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Retrieves a connection from the pool (error code version)</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">get_connection</span><span class="special">(</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">,</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">diagnostics</span><span class="special">&amp;</span> <span class="identifier">diag</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">duration</span> <span class="identifier">timeout</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">30</span><span class="special">)</span>
    <span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// The completion token to use for the async initiation function.</span>
        <span class="comment">// use_future will make the async function return a std::future object, which will</span>
        <span class="comment">// become ready when the operation completes.</span>
        <span class="comment">// as_tuple prevents the future from throwing on error, and packages the result as a tuple.</span>
        <span class="comment">// The returned future will be std::future&lt;std::tuple&lt;error_code, pooled_connection&gt;&gt;.</span>
        <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">completion_token</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">as_tuple</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">use_future</span><span class="special">);</span>

        <span class="comment">// We will use std::tie to decompose the tuple into its components.</span>
        <span class="comment">// We need to declare the connection before using std::tie</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">res</span><span class="special">;</span>

        <span class="comment">// async_get_connection returns a future. Calling std::future::get will</span>
        <span class="comment">// wait for the future to become ready</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">res</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">conn_pool_</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">timeout</span><span class="special">,</span> <span class="identifier">diag</span><span class="special">,</span> <span class="identifier">completion_token</span><span class="special">).</span><span class="identifier">get</span><span class="special">();</span>

        <span class="comment">// Done!</span>
        <span class="keyword">return</span> <span class="identifier">res</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Retrieves a connection from the pool (exception version)</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">get_connection</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">duration</span> <span class="identifier">timeout</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">30</span><span class="special">)</span>
    <span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// Call the error code version</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">diagnostics</span> <span class="identifier">diag</span><span class="special">;</span>
        <span class="keyword">auto</span> <span class="identifier">res</span> <span class="special">=</span> <span class="identifier">get_connection</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">diag</span><span class="special">,</span> <span class="identifier">timeout</span><span class="special">);</span>

        <span class="comment">// This will throw boost::mysql::error_with_diagnostics on error</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">throw_on_error</span><span class="special">(</span><span class="identifier">ec</span><span class="special">,</span> <span class="identifier">diag</span><span class="special">);</span>

        <span class="comment">// Done</span>
        <span class="keyword">return</span> <span class="identifier">res</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<h4>
<a name="mysql.connection_pool.h7"></a>
      <span class="phrase"><a name="mysql.connection_pool.benchmarks"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.benchmarks">Benchmarks</a>
    </h4>
<p>
      A throughput benchmark has been conducted to assess the performance gain provided
      by <code class="computeroutput"><span class="identifier">connection_pool</span></code>. Benchmark
      code is under <code class="computeroutput"><span class="identifier">bench</span><span class="special">/</span><span class="identifier">connection_pool</span><span class="special">.</span><span class="identifier">cpp</span></code>. The test goes as follows:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The test consists of N = 10000 logically independent sessions. In an application
          like a webserver, this would map to handling N HTTP requests.
        </li>
<li class="listitem">
          Every logical session prepares a <code class="computeroutput"><span class="identifier">SELECT</span></code>
          statement and executes it. The statement matches a single row by primary
          key and retrieves a single, short string field (a lightweight query).
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">num_parallel</span></code> = 100 async
          agents are run in parallel. This means that, at any given point in time,
          no more than 100 parallel connections to MySQL are made.
        </li>
<li class="listitem">
          The test measures the time ellapsed between launching the first async agent
          and receiving the response for the last query (<code class="computeroutput"><span class="identifier">ellapsed_time</span></code>).
        </li>
<li class="listitem">
          The test is repeated 10 times for each different configuration, and results
          are averaged. This time is used to measure the throughput, in "connections/s"
          (as given by <code class="computeroutput"><span class="identifier">N</span><span class="special">/</span><span class="identifier">ellapsed_time</span></code>).
        </li>
<li class="listitem">
          Connection pool scenarios use <code class="computeroutput"><span class="identifier">pooled_connection</span><span class="special">::~</span><span class="identifier">pooled_connection</span></code>,
          which causes a connection reset to be issued. Raw connection scenarios
          use <a class="link" href="ref/boost__mysql__any_connection/async_connect.html" title="any_connection::async_connect"><code class="literal">any_connection::async_connect</code></a>
          and <a class="link" href="ref/boost__mysql__any_connection/async_close.html" title="any_connection::async_close"><code class="literal">any_connection::async_close</code></a>
          for every session. All tests are single-threaded.
        </li>
<li class="listitem">
          The server runs MySQL v8.0.33 in a Docker container, in the same machine
          as the benchmarks.
        </li>
<li class="listitem">
          Benchmarks have been compiled using clang-18 using CMake's Release build
          type and C++20. They've been run in a Ubuntu 22.04 machine with an 8 core
          i7-10510U and 32GB of RAM.
        </li>
</ul></div>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="images/connection_pool_bench.svg"></object></span>
    </p>
<p>
      We can see that pooling significantly increases throughput. This is specially
      true when communication with the server is expensive (as is the case when using
      TLS over TCP). The performance gain is likely to increase over high-latency
      networks, and to decrease for heavyweight queries, since the connection establishment
      has less overall weight.
    </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        When using TLS or running small and frequent queries, pooling can help you.
      </p></td></tr>
</table></div>
</div>
<div class="copyright-footer">Copyright © 2019-2023 Ruben Perez<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="any_connection.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="sql_formatting.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
